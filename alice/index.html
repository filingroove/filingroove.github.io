<!DOCTYPE html>
<html lang="ru">
<head>
	
	<meta charset="UTF-8">
	<title>Алиса в зазеркалье</title>

	<link rel="stylesheet" href="css/normalize.css">
	<link rel="stylesheet" href="css/common.css">

	<script type="text/javascript" src="js/jquery.min.js"></script>
	<script type="text/javascript" src="js/handlebars.runtime-v3.0.3.js"></script>
	<script type="text/javascript" src="page.templates"></script>
	<script type="text/javascript" src="contents.templates"></script>
	<script type="text/javascript" src="js/turn.min.js"></script>

</head>
<body>
	<div id="modal" class="overlay">
		<div id="loading" class="active">
			
		</div>

		<div id="contents">
			<div class="home-back"></div>
			<div class="contents-list">
				
			</div>
		</div>
	</div>

	<div id="container">

		<div class="arrow fuck-media-query-sadface"></div>
				
		<div id="book">
		
		</div>

		<div class="home fuck-media-query-sadface"></div>
		<div class="arrow right fuck-media-query-sadface"></div>

	</div>

	<div id="controls">
		<div class="arrow"></div>
		<div class="home"></div>
		<div class="arrow right"></div>
	</div>
	
	<script type="text/javascript" src="js/chess.min.js"></script>
	<script type="text/javascript" src="js/chessboard-0.3.0.min.js"></script>
	<script type="text/javascript">

		
		$(document).ready(function() {
			var pages, board;

			console.log("Init!");

			var resizeBook = function() {
				$('#book').turn("size", '36.8em', '23em');
				$('#book').turn("resize");
			}
			
			$.getJSON('json/alice.json', function(data) {

				$('#book').html(Handlebars.templates.page(data));
				$('#contents .contents-list').html(Handlebars.templates.contents(data));

				pages = data.pages.length+4;

				console.log("Partial rendered successfully!");

			}).done(function() {

				
				$('#book').turn({
					width: '36.8em',
					height: '23em',
					autoCenter: true
				});
				

				$(window).resize(resizeBook);

				/*$('#book').prepend('<div class="cover-back front"><div class="inner"></div></div>');
				$('#book').append('<div class="cover-back back"><div class="inner"></div></div>');*/

				$('#book').bind("turning", function(event, page, view) {
				  //console.log(page);

				  if (page === 6) {
				  	minigame.create();
				  }
				  
				});

				/*$('#book').bind("start", function(event, pageObject, corner) {
				  //console.log("start: "+pageObject.page);

				  if (pageObject.page === 5) {
				  	$('.cover-back.front').addClass('display');
				  }

				  if (pageObject.page === pages-4) {
				  	$('.cover-back.back').addClass('display');
				  }

				});*/

				$('.arrow').click(function() {
					if ($(this).hasClass('right')) {
						$("#book").turn("next");
					} else {
						$("#book").turn("previous");
					}					
				});

				$('.contents-link').click(function() {
					$('#book').turn("page", $(this).attr('data-page'));
					contents();
				})

				$('.home, .home-back').click(contents);

				$('#modal').removeClass('overlay');
				$('#loading').removeClass('active');

				console.log("this is what comes after");

			}).fail(function() {

				console.error("Failed! JSON not found or is not valid");

			})
		});

		function contents() {
			if ($('#modal').hasClass('modal')) {
				$('#modal').removeClass('modal');
				$('#contents').removeClass('active');
			} else {
				$('#modal').addClass('modal');
				$('#contents').addClass('active');
			}
		}

		function getCookie(cname) {
		    var name = cname + "=";
		    var ca = document.cookie.split(';');
		    for(var i=0; i<ca.length; i++) {
		        var c = ca[i];
		        while (c.charAt(0)==' ') c = c.substring(1);
		        if (c.indexOf(name) == 0) return c.substring(name.length,c.length);
		    }
		    return "";
		}



		var minigame = {
			game: null,
			create: function() {
						
				if (getCookie('fen')) {
					var position = getCookie('fen');
					minigame.game = new Chess(position);
				} else {
					var position = 'start'
					minigame.game = new Chess();
				}

				// do not pick up pieces if the game is over
				// only pick up pieces for White
				var onDragStart = function(source, piece, position, orientation) {
				  if (minigame.game.in_checkmate() === true || minigame.game.in_draw() === true ||
				    piece.search(/^b/) !== -1) {
				    return false;
				  }
				};

				var makeRandomMove = function() {
				  var possibleMoves = minigame.game.moves();

				  updateStatus();

				  // game over
				  if (possibleMoves.length === 0) return;

				  var randomIndex = Math.floor(Math.random() * possibleMoves.length);
				  minigame.game.move(possibleMoves[randomIndex]);

				  updateStatus();
				  board.position(minigame.game.fen());
				  document.cookie="fen="+minigame.game.fen();
				};

				var onDrop = function(source, target) {
				  // see if the move is legal
				  var move = minigame.game.move({
				    from: source,
				    to: target,
				    promotion: 'q' // NOTE: always promote to a queen for example simplicity
				  });

				  // illegal move
				  if (move === null) return 'snapback';

				  updateStatus();

				  // make random legal move for black
				  window.setTimeout(makeRandomMove, 250);
				};

				// update the board position after the piece snap
				// for castling, en passant, pawn promotion
				var onSnapEnd = function() {
				  board.position(minigame.game.fen());
				  document.cookie="fen="+minigame.game.fen();
				};

				var updateStatus = function() {
				  var status = '';

				  var moveColor = 'Біли';
				  if (minigame.game.turn() === 'b') {
				    moveColor = 'Чорни';
				  }

				  // checkmate?
				  if (minigame.game.in_checkmate() === true) {
				    status = 'Шах і мат, ' + moveColor + '!';
				  }

				  // draw?
				  else if (minigame.game.in_draw() === true) {
				    status = 'Нічия!';
				  }

				  // game still on
				  else {
				    status = 'Хід ' + moveColor + 'х';

				    // check?
				    if (minigame.game.in_check() === true) {
				      status += 'Шах' + moveColor + 'м';
				    }
				  }

				  $('#game-status').html(status);

				}

				var cfg = {
				  draggable: true,
				  position: position,
				  onDragStart: onDragStart,
				  onDrop: onDrop,
				  onSnapEnd: onSnapEnd
				};

				$('#game-reset').click(minigame.reset);

				board = new ChessBoard('board', cfg);

				updateStatus();
			},
			reset: function() {
				board.start();
				minigame.game.reset();

				document.cookie = 'fen=';
			}
		}
	</script>
</body>
</html>